<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CheckBoxAuto" xml:space="preserve">
    <value>auto</value>
  </data>
  <data name="CheckBoxBorderInner" xml:space="preserve">
    <value>innerer Rahmen</value>
  </data>
  <data name="CheckBoxBorderOuter" xml:space="preserve">
    <value>äußerer Rahmen</value>
  </data>
  <data name="CheckBoxGlass" xml:space="preserve">
    <value>type glass</value>
  </data>
  <data name="CheckBoxMirror" xml:space="preserve">
    <value>mirror</value>
  </data>
  <data name="CheckBoxRauto" xml:space="preserve">
    <value>rauto</value>
  </data>
  <data name="CheckBoxRef" xml:space="preserve">
    <value>ref</value>
  </data>
  <data name="CheckBoxRotate" xml:space="preserve">
    <value>rotate (x/y/z)</value>
  </data>
  <data name="CheckBoxScale" xml:space="preserve">
    <value>scale (x/y/z)</value>
  </data>
  <data name="CheckBoxShi" xml:space="preserve">
    <value>shi</value>
  </data>
  <data name="CheckBoxThumb" xml:space="preserve">
    <value>Thumb erstellen</value>
  </data>
  <data name="CheckBoxTra" xml:space="preserve">
    <value>tra</value>
  </data>
  <data name="GroupSettings" xml:space="preserve">
    <value>Einstellungen</value>
  </data>
  <data name="GroupThumbnails" xml:space="preserve">
    <value>Thumbnails</value>
  </data>
  <data name="LabelColorName" xml:space="preserve">
    <value>Farbname:</value>
  </data>
  <data name="LabelThumb" xml:space="preserve">
    <value>Ordner:</value>
  </data>
  <data name="MatFileGenTitle" xml:space="preserve">
    <value>Mat-Files-Generator</value>
  </data>
  <data name="StatusBarChecked" xml:space="preserve">
    <value>{0} ausgewählt</value>
  </data>
  <data name="StatusBarUnchecked" xml:space="preserve">
    <value>{0} abgewählt</value>
  </data>
  <data name="TabItemSolid" xml:space="preserve">
    <value>_2. Solid</value>
  </data>
  <data name="TabItemTexture" xml:space="preserve">
    <value>_1. Textur</value>
  </data>
  <data name="TextBlockColorHex" xml:space="preserve">
    <value>Farbe als HEX:</value>
  </data>
  <data name="TextBlockColorRgb" xml:space="preserve">
    <value>Farbe als RGB:</value>
  </data>
  <data name="TextBlockColorSelection" xml:space="preserve">
    <value>Farbe auswählen:</value>
  </data>
  <data name="ToolTipAuto" xml:space="preserve">
    <value>Automatisches Texturaufbringung auf eine allgemeine viereckige Fläche.</value>
  </data>
  <data name="ToolTipBorderInner" xml:space="preserve">
    <value>Die Einstellungen für den inneren Rahmen des Vorschaubildes.</value>
  </data>
  <data name="ToolTipBorderOuter" xml:space="preserve">
    <value>Die Einstellungen für den äußeren Rahmen des Vorschaubildes.</value>
  </data>
  <data name="ToolTipBorderSize" xml:space="preserve">
    <value>Angabe in Pixel</value>
  </data>
  <data name="ToolTipColorHex" xml:space="preserve">
    <value>Für einen einfachen Lack kann hier der Farbwert als Hex-Wert eingegeben werden.</value>
  </data>
  <data name="ToolTipColorHexInput" xml:space="preserve">
    <value>Den Farbwert in Form "#112233" eintragen!</value>
  </data>
  <data name="ToolTipColorName" xml:space="preserve">
    <value>der Farbname (ohne Dateiendung)</value>
  </data>
  <data name="ToolTipColorRgb" xml:space="preserve">
    <value>Für einen einfachen Lack kann hier der RGB-Farbwert (von 0 bis 255) eingegeben werden.</value>
  </data>
  <data name="ToolTipColorSelection" xml:space="preserve">
    <value>Für einen einfachen Lack kann hier der Farbwert ausgewählt werden.</value>
  </data>
  <data name="ToolTipGlass" xml:space="preserve">
    <value>Beschreibt, ob es sich um ein Material aus Glas handelt. Die Werte 0 und 1 sind möglich.</value>
  </data>
  <data name="ToolTipMirror" xml:space="preserve">
    <value>Steuert die Spiegeloberfläche. Werte 0 bis 1 sind möglich. 1 bedeutet volle Spiegelung; 0.5 könnte man z. B. für Hochglanz-Lackfront verwenden.</value>
  </data>
  <data name="ToolTipRauto" xml:space="preserve">
    <value>Skalierung der Textur auf die Größe der gesamten Fläche.</value>
  </data>
  <data name="ToolTipRef" xml:space="preserve">
    <value>Der Schlüssel "ref" spezifiziert die Brechung durch eine positive Gleitkommazahl. Die initiale Brechung hat den Wert 1.0 und entspricht dem Brechungswert im Vakuum.</value>
  </data>
  <data name="ToolTipRotate" xml:space="preserve">
    <value>Rotiert das JPG. Interessant ist hier nur die Z-Achse. Die Werte bei den X- und Y-Achsen bleiben auf 0.</value>
  </data>
  <data name="ToolTipScale" xml:space="preserve">
    <value>Hierüber wird die Skalierung verändert. Benötigt wird dies natürlich nur, wenn mit Texturen gearbeitet wird. Die einzelnen Werte besagen, wie oft das JPG pro Meter dargestellt wird (Werte sind für X, Y und Z).</value>
  </data>
  <data name="ToolTipShi" xml:space="preserve">
    <value>Der Schlüssel "shi" spezifiziert den spekularen Exponent durch eine positive Gleitkommazahl. Je höher der Exponent ist, desto geringer ist die Ausbreitung der spekularen Highlights. Der initiale Exponent hat den Wert 30.0.</value>
  </data>
  <data name="ToolTipThumb" xml:space="preserve">
    <value>Erstellt zusätzlich ein Thumbnail in den Abmessungen 50x25 Pixel. Gespeichert wird dies im angegebenen Ordner.</value>
  </data>
  <data name="ToolTipTra" xml:space="preserve">
    <value>Der Schlüssel "tra" spezifiziert die Transparenz durch eine nicht negative Gleitkommazahl, die &lt;= 1 ist. Der Wert 0.0 steht für völlige Undurchlässigkeit; der Wert 1.0 bedeutet totale Transparenz. Der Initialwert beträgt 0.0.</value>
  </data>
</root>